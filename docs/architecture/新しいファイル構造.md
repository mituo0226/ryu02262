# プラグインアーキテクチャ - 新しいファイル構造

## 概要

プラグインアーキテクチャを実装し、チャットシステムを完全にキャラクター非依存にしました。
新しい鑑定士を追加する際も、チャットエンジンを変更する必要はありません。

## ファイル構造

```
public/
├── js/
│   ├── character-registry.js          # ハンドラーの登録・管理
│   ├── character-loader.js            # ハンドラーの動的読み込み
│   ├── chat-engine.js                 # チャットエンジン（完全にキャラクター非依存）
│   ├── auth-state.js                  # 認証状態管理
│   ├── character-features.js          # キャラクター機能
│   ├── chat-api.js                    # チャットAPI
│   ├── chat-data.js                   # チャットデータ管理
│   ├── chat-ui.js                     # チャットUI
│   ├── guest-limit-manager.js         # ゲスト制限管理
│   └── character-handlers/
│       ├── registry.json              # 利用可能なハンドラーの一覧
│       ├── README.md                  # ハンドラーの説明
│       ├── kaede/
│       │   ├── handler.js             # 楓専用ハンドラー
│       │   └── config.json            # 楓の設定
│       ├── yukino/
│       │   ├── handler.js             # 雪乃専用ハンドラー
│       │   └── config.json            # 雪乃の設定
│       ├── sora/
│       │   ├── handler.js             # ソラ専用ハンドラー
│       │   └── config.json            # ソラの設定
│       └── kaon/
│           ├── handler.js             # 薫音専用ハンドラー
│           └── config.json            # 薫音の設定
│
└── pages/
    └── chat/
        ├── chat.html                  # チャット画面（動的読み込み方式）
        └── guest-chat.html           # ゲストチャット画面（動的読み込み方式）
```

## 主要ファイルの説明

### 1. character-registry.js
ハンドラーの登録・管理を行うレジストリ。
- `register(characterId, handler, config)`: ハンドラーを登録
- `get(characterId)`: ハンドラーを取得
- `getAll()`: すべてのハンドラーを取得
- `has(characterId)`: ハンドラーが登録されているか確認

### 2. character-loader.js
ハンドラーの動的読み込みを管理。
- `loadHandler(characterId)`: 特定のハンドラーを読み込む
- `loadHandlerFromURL()`: URLパラメータからハンドラーを読み込む
- `loadRegistry()`: レジストリファイルから利用可能なハンドラーを取得

### 3. chat-engine.js
完全にキャラクター非依存のチャットエンジン。
- キャラクター固有の処理は一切含まれない
- すべての処理をハンドラーに委譲
- `CharacterRegistry`を使用してハンドラーにアクセス

### 4. character-handlers/[character-id]/handler.js
各キャラクター専用のハンドラー。
- `init()`: 初期化処理
- `initPage(urlParams, historyData, justRegistered, shouldTriggerRegistrationFlow)`: ページ初期化
- `handleResponse(response, character)`: APIレスポンス処理
- `handlePostRegistration(historyData, guestHistory)`: 登録完了後処理
- その他、キャラクター固有のメソッド

### 5. character-handlers/[character-id]/config.json
各キャラクターの設定ファイル。
```json
{
  "characterId": "kaede",
  "handlerClassName": "KaedeHandler",
  "name": "楓",
  "image": "../../photo/kaede.png",
  "features": ["guardian-ritual"],
  "messageLimit": 10,
  "specialBehaviors": {
    "guardianRitual": {
      "enabled": true,
      "triggerAt": 10
    }
  }
}
```

### 6. character-handlers/registry.json
利用可能なハンドラーの一覧。
```json
{
  "version": "1.0.0",
  "characters": [
    "kaede",
    "yukino",
    "sora",
    "kaon"
  ],
  "description": "利用可能なキャラクターハンドラーの一覧。新しいキャラクターを追加する場合は、この配列に追加してください。"
}
```

## 新しい鑑定士を追加する方法

### ステップ1: ディレクトリとファイルを作成

```
public/js/character-handlers/[new-character-id]/
├── handler.js
└── config.json
```

### ステップ2: handler.jsを作成

```javascript
const [CharacterName]Handler = {
    characterId: '[character-id]',
    characterName: '[キャラクター名]',

    init() {
        console.log('[キャラクター名ハンドラー] 初期化');
        // 初期化処理
    },

    // 共通インターフェースを実装
    initPage(urlParams, historyData, justRegistered, shouldTriggerRegistrationFlow) {
        // ページ初期化処理
        return null;
    },

    handleResponse(response, character) {
        // APIレスポンス処理
        return false; // 共通処理を続行
    },

    handlePostRegistration(historyData, guestHistory = []) {
        // 登録完了後処理
        return false; // 共通処理を続行
    },

    // その他のキャラクター固有のメソッド
};

// グローバルスコープに公開
window.[CharacterName]Handler = [CharacterName]Handler;
```

### ステップ3: config.jsonを作成

```json
{
  "characterId": "[character-id]",
  "handlerClassName": "[CharacterName]Handler",
  "name": "[キャラクター名]",
  "image": "../../photo/[character-id].png",
  "features": [],
  "messageLimit": 10,
  "specialBehaviors": {}
}
```

### ステップ4: registry.jsonに追加

```json
{
  "version": "1.0.0",
  "characters": [
    "kaede",
    "yukino",
    "sora",
    "kaon",
    "[new-character-id]"
  ]
}
```

### ステップ5: 完了

これで新しい鑑定士が追加されました。チャットエンジン（`chat-engine.js`）の変更は不要です。

## HTMLファイルでの使用方法

### chat.html / guest-chat.html

```html
<!-- プラグインアーキテクチャ -->
<script src="../../js/character-registry.js"></script>
<script src="../../js/character-loader.js"></script>
<!-- チャットエンジン -->
<script src="../../js/chat-engine.js"></script>
<!-- ハンドラーの動的読み込み -->
<script>
(async function() {
    // URLパラメータからキャラクターIDを取得
    const urlParams = new URLSearchParams(window.location.search);
    const characterId = urlParams.get('character');
    
    if (characterId) {
        // 必要なハンドラーのみを読み込む
        const success = await CharacterLoader.loadHandler(characterId);
        if (success) {
            console.log('[初期化] ハンドラーを読み込みました:', characterId);
            // ハンドラーの初期化を実行
            const handler = CharacterRegistry.get(characterId);
            if (handler && typeof handler.init === 'function') {
                handler.init();
            }
        } else {
            console.error('[初期化] ハンドラーの読み込みに失敗しました:', characterId);
        }
    }
    
    // チャットエンジンを初期化
    if (window.ChatInit && typeof window.ChatInit.initPage === 'function') {
        await window.ChatInit.initPage();
    }
})();
</script>
```

## メリット

### 1. 完全な分離
- チャットエンジンはキャラクター情報を一切持たない
- 各ハンドラーは完全に独立
- 新しい鑑定士を追加してもチャットエンジンを変更する必要がない

### 2. 動的読み込み
- 必要なハンドラーのみを読み込む（パフォーマンス向上）
- ハンドラーの追加・削除が容易
- 設定ファイルで管理が可能

### 3. 保守性の向上
- 各鑑定士のロジックが個別ディレクトリに分離
- 設定とロジックが分離されている
- テストが容易

### 4. 拡張性
- 新しい鑑定士を追加する際：
  1. `character-handlers/[new-character-id]/`ディレクトリを作成
  2. `handler.js`と`config.json`を作成
  3. `registry.json`に追加
  4. 完了（チャットエンジンの変更は不要）

## 削除されたファイル

以下のファイルは削除され、新しい構造に移行されました：

- `public/js/chat-init.js` → `public/js/chat-engine.js`に改名
- `public/js/character-handlers/kaede-handler.js` → `public/js/character-handlers/kaede/handler.js`に移動
- `public/js/character-handlers/yukino-handler.js` → `public/js/character-handlers/yukino/handler.js`に移動
- `public/js/character-handlers/sora-handler.js` → `public/js/character-handlers/sora/handler.js`に移動
- `public/js/character-handlers/kaon-handler.js` → `public/js/character-handlers/kaon/handler.js`に移動

## 注意事項

1. **パスの問題**: `character-loader.js`内で使用するパスは絶対パス（`/js/...`）を使用しています。これはCloudflare Pagesで正しく動作します。

2. **後方互換性**: 旧形式のハンドラーファイル（`[character-id]-handler.js`）も読み込めるようにフォールバック機能を実装しています。

3. **ハンドラーの初期化**: ハンドラーの`init()`メソッドは、HTMLファイル内のスクリプトで呼び出されます。

4. **CharacterRegistry**: `CharacterHandlerRegistry`は`CharacterRegistry`に置き換えられました。`chat-engine.js`内では`CharacterRegistry.get()`を使用します。

## 更新日

2024年12月（プラグインアーキテクチャ実装時）
