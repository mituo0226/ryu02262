# 最適なチャットシステムアーキテクチャ提案

## 現状の問題点

1. **chat-init.jsが肥大化**: 2800行以上のコード、修正が困難
2. **キャラクター情報の混在**: チャット本体にキャラクター固有の処理が残っている
3. **ハードコードされた依存関係**: HTMLで各ハンドラーを個別に読み込む必要がある
4. **拡張性の欠如**: 新しい鑑定士を追加する際、複数ファイルを修正する必要がある

## 提案する最適な構造

### 1. 完全なプラグインアーキテクチャ

```
public/js/
├── chat-engine.js          # 完全にキャラクター非依存のチャットエンジン
├── character-registry.js    # ハンドラーの動的登録・管理
├── character-loader.js      # ハンドラーの動的読み込み
└── character-handlers/
    ├── registry.json       # 利用可能なハンドラーの一覧
    ├── kaede/
    │   ├── handler.js      # ハンドラー本体
    │   └── config.json     # 鑑定士固有の設定
    ├── yukino/
    │   ├── handler.js
    │   └── config.json
    └── [character-id]/
        ├── handler.js
        └── config.json
```

### 2. チャットエンジン（chat-engine.js）の責務

**完全にキャラクター非依存**:
- メッセージ送受信の基本フロー
- UI更新（メッセージ表示、スクロールなど）
- 会話履歴の管理（キャラクター非依存）
- イベントループ（メッセージ送信→API呼び出し→レスポンス処理）

**キャラクター固有の処理は一切含まない**:
- キャラクター名の直接比較（`character === 'kaede'`など）は一切なし
- すべての処理をハンドラーに委譲
- ハンドラーが見つからない場合はデフォルト動作

### 3. ハンドラーレジストリ（character-registry.js）

```javascript
const CharacterRegistry = {
    handlers: new Map(),
    
    // ハンドラーを登録
    register(characterId, handler) {
        this.handlers.set(characterId, handler);
    },
    
    // ハンドラーを取得
    get(characterId) {
        return this.handlers.get(characterId) || null;
    },
    
    // すべてのハンドラーを取得
    getAll() {
        return Array.from(this.handlers.values());
    }
};
```

### 4. ハンドラーローダー（character-loader.js）

```javascript
const CharacterLoader = {
    // 利用可能なハンドラーを自動検出
    async discoverHandlers() {
        const registryResponse = await fetch('/js/character-handlers/registry.json');
        const registry = await registryResponse.json();
        
        for (const characterId of registry.characters) {
            await this.loadHandler(characterId);
        }
    },
    
    // 特定のハンドラーを読み込む
    async loadHandler(characterId) {
        // 1. 設定ファイルを読み込む
        const configResponse = await fetch(`/js/character-handlers/${characterId}/config.json`);
        const config = await configResponse.json();
        
        // 2. ハンドラースクリプトを動的に読み込む
        await this.loadScript(`/js/character-handlers/${characterId}/handler.js`);
        
        // 3. ハンドラーを初期化して登録
        const handler = window[config.handlerClassName];
        if (handler) {
            handler.init(config);
            CharacterRegistry.register(characterId, handler);
        }
    }
};
```

### 5. 各ハンドラーの構造

```javascript
// character-handlers/kaede/handler.js
const KaedeHandler = {
    characterId: 'kaede',
    config: null,
    
    init(config) {
        this.config = config;
        // 初期化処理
    },
    
    // 共通インターフェース
    handleResponse(response) { /* ... */ },
    handlePostRegistration(historyData) { /* ... */ },
    // ... その他のメソッド
};

window.KaedeHandler = KaedeHandler;
```

```json
// character-handlers/kaede/config.json
{
    "characterId": "kaede",
    "handlerClassName": "KaedeHandler",
    "name": "楓",
    "image": "/photo/kaede.png",
    "features": ["guardian-ritual"],
    "messageLimit": 10,
    "specialBehaviors": {
        "guardianRitual": {
            "enabled": true,
            "triggerAt": 10
        }
    }
}
```

### 6. レジストリファイル（registry.json）

```json
{
    "characters": [
        "kaede",
        "yukino",
        "sora",
        "kaon"
    ],
    "version": "1.0.0"
}
```

## 実装の流れ

### ステップ1: チャットエンジンの分離

1. `chat-init.js`からすべてのキャラクター固有の処理を削除
2. ハンドラー呼び出しのみを残す
3. ファイル名を`chat-engine.js`に変更

### ステップ2: ハンドラーローダーの実装

1. `character-loader.js`を作成
2. `registry.json`から利用可能なハンドラーを検出
3. 必要なハンドラーのみを動的に読み込む

### ステップ3: ハンドラーの再構成

1. 各ハンドラーを個別ディレクトリに移動
2. 各ハンドラーに`config.json`を追加
3. ハンドラーを完全に独立させる

### ステップ4: HTMLの簡素化

```html
<!-- 以前: 各ハンドラーを個別に読み込む -->
<script src="../../js/character-handlers/kaede-handler.js"></script>
<script src="../../js/character-handlers/yukino-handler.js"></script>
<!-- ... -->

<!-- 以後: ローダーが自動的に読み込む -->
<script src="../../js/character-registry.js"></script>
<script src="../../js/character-loader.js"></script>
<script>
    // URLパラメータからキャラクターIDを取得
    const urlParams = new URLSearchParams(window.location.search);
    const characterId = urlParams.get('character');
    
    // 必要なハンドラーのみを読み込む
    CharacterLoader.loadHandler(characterId).then(() => {
        // チャットエンジンを初期化
        ChatEngine.init();
    });
</script>
```

## メリット

### 1. 完全な分離
- チャットエンジンはキャラクター情報を一切持たない
- 各ハンドラーは完全に独立
- 新しい鑑定士を追加してもチャットエンジンを変更する必要がない

### 2. 動的読み込み
- 必要なハンドラーのみを読み込む（パフォーマンス向上）
- ハンドラーの追加・削除が容易
- 設定ファイルで管理が可能

### 3. 保守性の向上
- 各鑑定士のロジックが個別ディレクトリに分離
- 設定とロジックが分離されている
- テストが容易

### 4. 拡張性
- 新しい鑑定士を追加する際：
  1. `character-handlers/[new-character]/`ディレクトリを作成
  2. `handler.js`と`config.json`を作成
  3. `registry.json`に追加
  4. 完了（チャットエンジンの変更は不要）

## 移行計画

### フェーズ1: 基盤の構築
1. `character-registry.js`を作成
2. `character-loader.js`を作成
3. `registry.json`を作成

### フェーズ2: ハンドラーの再構成
1. 各ハンドラーを個別ディレクトリに移動
2. 各ハンドラーに`config.json`を追加
3. ハンドラーの初期化方法を統一

### フェーズ3: チャットエンジンの分離
1. `chat-init.js`からキャラクター固有の処理を完全に削除
2. ハンドラー呼び出しのみを残す
3. ファイル名を`chat-engine.js`に変更

### フェーズ4: HTMLの更新
1. すべてのチャットHTMLファイルを更新
2. 動的読み込み方式に変更

## 注意事項

1. **後方互換性**: 既存のハンドラーが動作することを確認
2. **エラーハンドリング**: ハンドラーが見つからない場合のフォールバック
3. **パフォーマンス**: 動的読み込みによる初期化時間の増加を最小化
4. **テスト**: 各ハンドラーが独立してテスト可能であることを確認
